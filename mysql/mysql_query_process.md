##  一条查询SQL的执行过程

##### 执行流程

- 客户端发送请求到服务端建立连接
- 服务端先查看缓存是否命中，命中则直接返回，否则继续往下执行
- 接着来到解析器，进行语法分析，一些熊关键字校验，校验语法是否合规
- 然后优化器进行SQL优化，比如选择索引之类，然后生成执行计划
- 最后执行引擎调用存储引擎API查询数据，返回结果

##### 流程图

<img src="F:\code\study\github\blog\mysql\c54d503410a84031be8c7ca0ad4f3374.jpeg" alt="c54d503410a84031be8c7ca0ad4f3374" style="zoom:40%;" />



##### 查询缓存

查询缓存在5.7.20版本已经被弃用，并且8.0的版本已经删除了

```
# 查看查询缓存是否可用
SHOW VARIABLES LIKE 'have_query_cache';

query_cache_type：是否打开查询缓存，值为0\1\2，分别对应为OFF\ON\DEMAND，ON的话则代表开启查询缓存，但是可以通过SELECT SQL_NO_CACHE来手动禁用，DEMAND则代表只缓存以SELECT SQL_CACHE开头的SQL语句

query_cache_limit：缓存结果大小限制，如果查询结果超过大小则不会被缓存，默认是1M大小。

query_cache_size：为查询缓存分配的内存大小，他是1024的整数倍。

query_cache_min_res_unit：查询缓存分配内存块的最小单位，默认为4KB。这是查询缓存分配内存的基本单位，即便比如查询的数据只有1个字节，也会按照最小内存单元大小来分配内存空间。
```

在进行SQL解析之前，系统会判断查询缓存是否打开，如果打开，就拿缓存中的查询和传入的查询比较，**如果完全一样**，就会从缓存中直接返回。

但是需要特别注意的是，**无论大小写、空格还是注释**，都会影响缓存的命中结果，也就是说必须完全一样！



##### 解析器&预处理器

如果查询缓存未命中，就会进入正常的SQL执行环节

解析器会进行词法语法分析，基于语法规则对SQL进行校验。如果校验OK，那么就生成一颗“解析树”。



##### 优化器



![f43674cd30464efd9c8624b6d44000b0](F:\code\study\github\blog\mysql\f43674cd30464efd9c8624b6d44000b0.jpeg)



##### 执行引擎

最后执行引擎只要根据生成好的执行计划查询数据返回就好了。



##### 总结

![51e9c10baa3f494591692db243a55b7c](F:\code\study\github\blog\mysql\51e9c10baa3f494591692db243a55b7c.jpeg)



#### 来源

https://m.toutiao.com/i6992022503174586919
