##  Innodb事务隔离性实现原理

#### 快照读

**解释**：也称为一致非锁定读或一致性读，即不加锁的非阻塞读

**前提**： 快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读

**优点**：基于提高并发性能的考虑，避免了加锁操作，降低了开销

**实现**：快照读的实现是基于多版本并发控制，即MVCC

**效果**：既然是基于多版本，即**快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本**

**语法**：一般的select就是快照读



#### 当前读

**效果**：**读取的是记录的最新版本**

**实现**：读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

**语法**：select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)。全是需要加锁的。



#### 事务ID

InnoDB 里面每个事务有一个**唯一**的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序**严格递增**的。



#### Undo log

对每行数据进行操作之前都会记录Undo Log，目的是能将数据进行回滚。

同一个事务对数据进行多次修改或者多个事务对同一个数据进行修改，这些**修改会按照时间顺序连成链**，所以通过undo log可以发现数据修改的历史。

Undo Log主要分为两种：

**insert undo log**：代表事务在insert新记录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃

**update undo log**：事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除



#### 行结构

表中每一行的数据，除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段。

DB_TRX_ID：6byte，最近修改(修改/插入)**事务ID**。记录创建这条记录/最后一次修改该记录的事务ID

DB_ROLL_PTR：7byte，回滚指针，指向这条**记录的上一个版本**（存储于rollback segment里），本质上利用undo log的能力

DB_ROW_ID：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引



<img src="F:\code\study\github\blog\mysql\0e24aa7598794ec399678540a7d9b53d.png" alt="0e24aa7598794ec399678540a7d9b53d" style="zoom:50%;" />



#### 数据可见性规则

- 如果落在绿色部分，表示这个版本是已提交的事务，这个数据是可见的；
- 如果事务id是自己的值，表示数据是可见的;
- 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
- 如果落在黄色部分，那就包括两种情况a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。



   表中有值(id:1,k:1)，有三个事务进行操作，问事务B和事务A通过select获取的值分别是多少？

<img src="F:\code\study\github\blog\mysql\3a75b9d499ac4cea8d08e5e377750193.png" alt="3a75b9d499ac4cea8d08e5e377750193" style="zoom:50%;" />



事务B查到的是3，事务A查到的是1。

事务A

​		事务A查到1比较容易理解，根据可见性规则，事务B和事务C'对事务A而言都属于未开始事务，所以等事务A查找的时候，会不断回溯，找到（1，1）。

事务B:

1. 在讲当前读的时候，select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)都是当前读，对修改的那行数据都加了锁。所以必须事务C'提交完后，事务B的update才能继续执行，否则事务B**阻塞**。
2. update先当前读，后写，行数据被真正的进行了修改，行数据中的DB_TRX_ID已经是事务B的事务ID，根据可见性规则，事务B查询到的值变为了3。

推论：

1. 如果事务B在操作update之前，执行一次select k from t where id=1，查到的值为1。这种情况经常会让大家认为快照读失效了，其实这是符合数据可见性规则的。
2. 如果事务A的select改为select k from t where id=1 lock in share mode，查到的值是3。当然，只有事务B提交后， lock in share mode才能执行，否则会被阻塞。



#### 来源

https://www.toutiao.com/i6996548293547360772/